{"ast":null,"code":"// '/index.html',\n// '/static/css/main.71bb5dc8.chunk.css',\n// '/static/js/1.3101dea3.chunk.js',\n// '/static/js/main.d494b740.chunk.js',\n// '/static/js/runtime~main.229c360f.js'\nexport function register() {\n  // Service Worker\n  var pwaCache = 'pwa-cache-1';\n  console.log(\"WORKING\"); //set up the cache on installing SW\n\n  window.addEventListener('install', function (e) {\n    var cacheReady = caches.open(pwaCache).then(function (cache) {\n      console.log('new cache ready');\n      return cache.addAll([]);\n    });\n    e.waitUntil(cacheReady);\n  }); //listen to activate to clean up old caches\n\n  window.addEventListener('activate', function (e) {\n    var cachesCleaned = caches.keys().then(function (keys) {\n      keys.forEach(function (key) {\n        if (key !== pwaCache) {\n          return caches.delete(key);\n        }\n      });\n    });\n    e.waitUntil(cachesCleaned);\n  }); //send cached stuff when fetches are called\n\n  window.addEventListener('fetch', function (e) {\n    //if not local, don't bother trying to get from cache\n    if (!e.request.url === window.location.origin) return; //is local, lets get from cache\n\n    var newRes = caches.open(pwaCache).then(function (cache) {\n      return cache.match(e.request).then(function (res) {\n        //check request was found in cache\n        if (res) {\n          console.log(\"Serving \".concat(res.url, \" from cache\"));\n          return res;\n        } //fetch on behalf of client and then cache\n\n\n        return fetch(e.request).then(function (fetchRes) {\n          //next line is complicated.\n          //shouldnt just use add() bc that calls a fetch, unnecessary\n          //need to clone since fetchRes can only be consumed once\n          cache.put(e.request, fetchRes.clone());\n          return fetchRes;\n        });\n      });\n    });\n    e.respondWith(newRes);\n  });\n}","map":{"version":3,"sources":["/Users/benreimer/Develop/stacks/stacks-v3/src/sw.js"],"names":["register","pwaCache","console","log","window","addEventListener","e","cacheReady","caches","open","then","cache","addAll","waitUntil","cachesCleaned","keys","forEach","key","delete","request","url","location","origin","newRes","match","res","fetch","fetchRes","put","clone","respondWith"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAGA,OAAO,SAASA,QAAT,GAAmB;AAI1B;AACA,MAAMC,QAAQ,GAAG,aAAjB;AAEAC,EAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAP0B,CAS1B;;AACAC,EAAAA,MAAM,CAACC,gBAAP,CAAwB,SAAxB,EAAmC,UAAAC,CAAC,EAAI;AAItC,QAAIC,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYR,QAAZ,EAAsBS,IAAtB,CAA4B,UAAAC,KAAK,EAAI;AACpDT,MAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACA,aAAOQ,KAAK,CAACC,MAAN,CAAa,EAAb,CAAP;AAGD,KALgB,CAAjB;AAOAN,IAAAA,CAAC,CAACO,SAAF,CAAYN,UAAZ;AACD,GAZD,EAV0B,CAyB1B;;AAEAH,EAAAA,MAAM,CAACC,gBAAP,CAAwB,UAAxB,EAAoC,UAAAC,CAAC,EAAI;AAEvC,QAAIQ,aAAa,GAAGN,MAAM,CAACO,IAAP,GAAcL,IAAd,CAAoB,UAAAK,IAAI,EAAI;AAC9CA,MAAAA,IAAI,CAACC,OAAL,CAAa,UAAAC,GAAG,EAAI;AAClB,YAAIA,GAAG,KAAKhB,QAAZ,EAAsB;AACpB,iBAAOO,MAAM,CAACU,MAAP,CAAcD,GAAd,CAAP;AACD;AACF,OAJD;AAKD,KANmB,CAApB;AAOAX,IAAAA,CAAC,CAACO,SAAF,CAAYC,aAAZ;AACD,GAVD,EA3B0B,CAwC1B;;AAGAV,EAAAA,MAAM,CAACC,gBAAP,CAAwB,OAAxB,EAAiC,UAAAC,CAAC,EAAI;AAEpC;AACA,QAAK,CAACA,CAAC,CAACa,OAAF,CAAUC,GAAX,KAAmBhB,MAAM,CAACiB,QAAP,CAAgBC,MAAxC,EAAgD,OAHZ,CAKpC;;AACA,QAAIC,MAAM,GAAGf,MAAM,CAACC,IAAP,CAAYR,QAAZ,EAAsBS,IAAtB,CAA4B,UAAAC,KAAK,EAAI;AAChD,aAAOA,KAAK,CAACa,KAAN,CAAYlB,CAAC,CAACa,OAAd,EAAuBT,IAAvB,CAA6B,UAAAe,GAAG,EAAI;AAEzC;AACA,YAAIA,GAAJ,EAAS;AACPvB,UAAAA,OAAO,CAACC,GAAR,mBAAuBsB,GAAG,CAACL,GAA3B;AACA,iBAAOK,GAAP;AACD,SANwC,CAQzC;;;AACA,eAAOC,KAAK,CAACpB,CAAC,CAACa,OAAH,CAAL,CAAiBT,IAAjB,CAAuB,UAAAiB,QAAQ,EAAI;AAExC;AACA;AACA;AACAhB,UAAAA,KAAK,CAACiB,GAAN,CAAUtB,CAAC,CAACa,OAAZ,EAAqBQ,QAAQ,CAACE,KAAT,EAArB;AACA,iBAAOF,QAAP;AACD,SAPM,CAAP;AASD,OAlBM,CAAP;AAmBD,KApBY,CAAb;AAqBArB,IAAAA,CAAC,CAACwB,WAAF,CAAcP,MAAd;AAED,GA7BD;AA+BC","sourcesContent":["// '/index.html',\n// '/static/css/main.71bb5dc8.chunk.css',\n// '/static/js/1.3101dea3.chunk.js',\n// '/static/js/main.d494b740.chunk.js',\n// '/static/js/runtime~main.229c360f.js'\n\n\nexport function register(){\n\n\n\n// Service Worker\nconst pwaCache = 'pwa-cache-1';\n\nconsole.log(\"WORKING\");\n\n//set up the cache on installing SW\nwindow.addEventListener('install', e => {\n\n\n\n  let cacheReady = caches.open(pwaCache).then( cache => {\n    console.log('new cache ready');\n    return cache.addAll([\n\n    ]);\n  })\n\n  e.waitUntil(cacheReady)\n})\n\n\n//listen to activate to clean up old caches\n\nwindow.addEventListener('activate', e => {\n\n  let cachesCleaned = caches.keys().then( keys => {\n    keys.forEach(key => {\n      if (key !== pwaCache) {\n        return caches.delete(key)\n      }\n    })\n  })\n  e.waitUntil(cachesCleaned);\n})\n\n\n//send cached stuff when fetches are called\n\n\nwindow.addEventListener('fetch', e => {\n\n  //if not local, don't bother trying to get from cache\n  if ( !e.request.url === window.location.origin) return;\n\n  //is local, lets get from cache\n  let newRes = caches.open(pwaCache).then( cache => {\n    return cache.match(e.request).then( res => {\n\n      //check request was found in cache\n      if (res) {\n        console.log(`Serving ${res.url} from cache`);\n        return res;\n      }\n\n      //fetch on behalf of client and then cache\n      return fetch(e.request).then( fetchRes => {\n\n        //next line is complicated.\n        //shouldnt just use add() bc that calls a fetch, unnecessary\n        //need to clone since fetchRes can only be consumed once\n        cache.put(e.request, fetchRes.clone())\n        return fetchRes;\n      })\n\n    });\n  })\n  e.respondWith(newRes);\n\n})\n\n}\n"]},"metadata":{},"sourceType":"module"}