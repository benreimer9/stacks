{"ast":null,"code":"// // '/index.html',\n// // '/static/css/main.71bb5dc8.chunk.css',\n// // '/static/js/1.3101dea3.chunk.js',\n// // '/static/js/main.d494b740.chunk.js',\n// // '/static/js/runtime~main.229c360f.js'\n//\n//\n// export function register(){\n//\n//\n//\n// // Service Worker\n// const pwaCache = 'pwa-cache-1';\n//\n// console.log(\"WORKING\");\n//\n// //set up the cache on installing SW\n// this.addEventListener('install', e => {\n//\n//\n//\n//   let cacheReady = caches.open(pwaCache).then( cache => {\n//     console.log('new cache ready');\n//     return cache.addAll([\n//\n//     ]);\n//   })\n//\n//   e.waitUntil(cacheReady)\n// })\n//\n//\n// //listen to activate to clean up old caches\n//\n// this.addEventListener('activate', e => {\n//\n//   let cachesCleaned = caches.keys().then( keys => {\n//     keys.forEach(key => {\n//       if (key !== pwaCache) {\n//         return caches.delete(key)\n//       }\n//     })\n//   })\n//   e.waitUntil(cachesCleaned);\n// })\n//\n//\n// //send cached stuff when fetches are called\n//\n//\n// this.addEventListener('fetch', e => {\n//\n//   //if not local, don't bother trying to get from cache\n//   if ( !e.request.url === location.origin) return;\n//\n//   //is local, lets get from cache\n//   let newRes = caches.open(pwaCache).then( cache => {\n//     return cache.match(e.request).then( res => {\n//\n//       //check request was found in cache\n//       if (res) {\n//         console.log(`Serving ${res.url} from cache`);\n//         return res;\n//       }\n//\n//       //fetch on behalf of client and then cache\n//       return fetch(e.request).then( fetchRes => {\n//\n//         //next line is complicated.\n//         //shouldnt just use add() bc that calls a fetch, unnecessary\n//         //need to clone since fetchRes can only be consumed once\n//         cache.put(e.request, fetchRes.clone())\n//         return fetchRes;\n//       })\n//\n//     });\n//   })\n//   e.respondWith(newRes);\n//\n// })\n//\n// }","map":{"version":3,"sources":["/Users/benreimer/Develop/stacks/stacks-v3/src/sw.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// // '/index.html',\n// // '/static/css/main.71bb5dc8.chunk.css',\n// // '/static/js/1.3101dea3.chunk.js',\n// // '/static/js/main.d494b740.chunk.js',\n// // '/static/js/runtime~main.229c360f.js'\n//\n//\n// export function register(){\n//\n//\n//\n// // Service Worker\n// const pwaCache = 'pwa-cache-1';\n//\n// console.log(\"WORKING\");\n//\n// //set up the cache on installing SW\n// this.addEventListener('install', e => {\n//\n//\n//\n//   let cacheReady = caches.open(pwaCache).then( cache => {\n//     console.log('new cache ready');\n//     return cache.addAll([\n//\n//     ]);\n//   })\n//\n//   e.waitUntil(cacheReady)\n// })\n//\n//\n// //listen to activate to clean up old caches\n//\n// this.addEventListener('activate', e => {\n//\n//   let cachesCleaned = caches.keys().then( keys => {\n//     keys.forEach(key => {\n//       if (key !== pwaCache) {\n//         return caches.delete(key)\n//       }\n//     })\n//   })\n//   e.waitUntil(cachesCleaned);\n// })\n//\n//\n// //send cached stuff when fetches are called\n//\n//\n// this.addEventListener('fetch', e => {\n//\n//   //if not local, don't bother trying to get from cache\n//   if ( !e.request.url === location.origin) return;\n//\n//   //is local, lets get from cache\n//   let newRes = caches.open(pwaCache).then( cache => {\n//     return cache.match(e.request).then( res => {\n//\n//       //check request was found in cache\n//       if (res) {\n//         console.log(`Serving ${res.url} from cache`);\n//         return res;\n//       }\n//\n//       //fetch on behalf of client and then cache\n//       return fetch(e.request).then( fetchRes => {\n//\n//         //next line is complicated.\n//         //shouldnt just use add() bc that calls a fetch, unnecessary\n//         //need to clone since fetchRes can only be consumed once\n//         cache.put(e.request, fetchRes.clone())\n//         return fetchRes;\n//       })\n//\n//     });\n//   })\n//   e.respondWith(newRes);\n//\n// })\n//\n// }\n"]},"metadata":{},"sourceType":"module"}